defmodule Butler.Schedules do
  @moduledoc """
  The Schedules context.
  """

  import Ecto.Query, warn: false
  alias Butler.Repo

  alias Butler.Schedules.Todo

  def subscribe(topic) do
    Phoenix.PubSub.subscribe(Butler.PubSub, topic)
  end

  defp broadcast({:ok, todo}, event) do
    # Broadcast changes only to the users that can see it.
    todo_topic = IO.iodata_to_binary(["todos:", todo.user_id])
    Phoenix.PubSub.broadcast(Butler.PubSub, todo_topic, {event, todo})

    {:ok, todo}
  end

  defp broadcast({:error, _changeset} = error, _event), do: error

  @doc """
  Returns the list of todos.

  ## Examples

      iex> list_todos()
      [%Todo{}, ...]

  """
  def list_todos(user_id) do
    query =
      from t in Todo,
      where: t.user_id == ^user_id,
      order_by: [desc: t.inserted_at]

    Repo.all(query)
  end

  @doc """
  Gets a single todo.

  Raises `Ecto.NoResultsError` if the Todo does not exist.

  ## Examples

      iex> get_todo!(123)
      %Todo{}

      iex> get_todo!(456)
      ** (Ecto.NoResultsError)

  """
  def get_todo!(id), do: Repo.get!(Todo, id)

  @doc """
  Creates a todo.

  ## Examples

      iex> create_todo(%{field: value})
      {:ok, %Todo{}}

      iex> create_todo(%{field: value}, [:user])
      {:ok, %Todo{user: %User{}}}

      iex> create_todo(%{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def create_todo(attrs \\ %{}, preload_opts \\ []) do
    maybe_todo =
      %Todo{}
      |> Todo.changeset(attrs)
      |> Repo.insert()

    case maybe_todo do
      {:ok, todo} ->
        broadcast({:ok, Repo.preload(todo, preload_opts)}, :created_todo)

      error_changeset_pair ->
        broadcast(error_changeset_pair, :created_todo)
    end
  end

  @doc """
  Updates a todo.

  ## Examples

      iex> update_todo(todo, %{field: new_value})
      {:ok, %Todo{}}

      iex> update_todo(todo, %{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def update_todo(%Todo{} = todo, attrs) do
    todo
    |> Todo.changeset(attrs)
    |> Repo.update()
  end

  @doc """
  Deletes a todo.

  ## Examples

      iex> delete_todo(todo)
      {:ok, %Todo{}}

      iex> delete_todo(todo)
      {:error, %Ecto.Changeset{}}

  """
  def delete_todo(%Todo{} = todo) do
    Repo.delete(todo)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking todo changes.

  ## Examples

      iex> change_todo(todo)
      %Ecto.Changeset{data: %Todo{}}

  """
  def change_todo(%Todo{} = todo, attrs \\ %{}) do
    Todo.changeset(todo, attrs)
  end

  # Auto-scheduler behavior
  alias Ecto.Multi

  def auto_assign(todos, time_streaks) do
    # TODO: Remove when selecting available slots is implemented.
    # TODO: Find a better way than this. It's really messy. :(
    time_streak_durations = Core.TimeStreak.get_durations(time_streaks, :matrix)
    todo_durations = Core.Todo.to_duration_matrix(todos)
    todo_priorities = Core.Todo.to_priority_matrix(todos)

    # Data to be accessed by the GA
    # TODO: Remove unnecessary data
    data = %{
      todo_ids: Enum.map(Enum.with_index(todos, 1), fn {_, index} -> index end),
      todos: todos,
      todo_size: length(todos),
      ts_size: length(time_streaks),
      time_streaks: time_streaks,
      time_streak_durations: time_streak_durations,
      durations: todo_durations,
      priorities: todo_priorities,
    }

    opts = [
      population_size: 100,
      # reinsertion_type: &Toolbox.Reinsertion.elitist/4,
      # selection_type: &Toolbox.Selection.unique_tournament/4,
      tournament_size: 5
    ]
    soln = Genetic.run(TTP, data, opts)

    # TODO: Find a way to log only in dev environment.
    # IO.write("\n===========> BEST SOLUTION\n")
    # IO.write("-----------> Fitness: #{soln.fitness}\n")
    # IO.write("-----------> Genes\n")

    # TODO: Update todos based on the time generated by GA.
    soln.genes
    |> Matrex.to_list_of_lists()
    |> Core.Timetable.from_bit_timetable()
    |> sort_todos(todos)
    |> Core.Timetable.from_schedule(todos, time_streaks, true)
    |> multi_update()
  end

  def multi_update(todos_with_changes) do
    multi = Multi.new()

    todos_with_changes
    |> Enum.reduce(multi, fn {todo, attrs}, m_acc ->
      changeset = change_todo(todo, attrs)
      Multi.update(m_acc, todo.id, changeset)
    end)
    |> Repo.transaction()
  end

  defp sort_todos(timetable, todos) do
    Enum.map(timetable, fn streak ->
      Enum.sort_by(
        streak,
        fn todo_id ->
          %{priority: p, duration: _d} = Core.Todo.get_todo(todos, trunc(todo_id - 1))

          p_val =
            case p do
              :none -> 1
              :low -> 2
              :medium -> 3
              :high -> 4
            end

          # :math.pow(p_val, d / 60)
          p_val
        end,
        :desc
      )
    end)
  end
end
