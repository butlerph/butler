defmodule Butler.Scheduler do
  alias Ecto.Multi

  def run(todos) do
    # TODO: Remove when selecting available slots is implemented.
    # TODO: Find a better way than this. It's really messy. :(
    # TODO: Make time_streaks user-defined.
    time_streaks = [
      {~N[2020-12-15 09:00:00.00], ~N[2020-12-15 12:00:00.00]},
      {~N[2020-12-15 13:00:00.00], ~N[2020-12-15 20:00:00.00]},
      {~N[2020-12-16 09:00:00.00], ~N[2020-12-16 12:00:00.00]},
      {~N[2020-12-16 13:00:00.00], ~N[2020-12-16 20:00:00.00]},
      {~N[2020-12-17 09:00:00.00], ~N[2020-12-17 12:00:00.00]},
      {~N[2020-12-17 13:00:00.00], ~N[2020-12-17 15:00:00.00]},
      {~N[2020-12-18 09:00:00.00], ~N[2020-12-18 12:00:00.00]},
      {~N[2020-12-18 13:00:00.00], ~N[2020-12-18 20:00:00.00]},
      {~N[2020-12-19 09:00:00.00], ~N[2020-12-19 12:00:00.00]},
      {~N[2020-12-19 13:00:00.00], ~N[2020-12-19 20:00:00.00]}
    ]
    time_streak_durations = Core.TimeStreak.get_durations(time_streaks, :matrix)
    todo_durations = Core.Todo.to_duration_matrix(todos)
    todo_priorities = Core.Todo.to_priority_matrix(todos)

    # Data to be accessed by the GA
    # TODO: Remove unnecessary data
    data = %{
      todo_ids: Enum.map(Enum.with_index(todos, 1), fn {_, index} -> index end),
      todos: todos,
      todo_size: length(todos),
      ts_size: length(time_streaks),
      time_streaks: time_streaks,
      time_streak_durations: time_streak_durations,
      durations: todo_durations,
      priorities: todo_priorities,
    }

    opts = [
      population_size: 100,
      # reinsertion_type: &Toolbox.Reinsertion.elitist/4,
      # selection_type: &Toolbox.Selection.unique_tournament/4,
      tournament_size: 5
    ]
    soln = Genetic.run(TTP, data, opts)

    # TODO: Find a way to log only in dev environment.
    # IO.write("\n===========> BEST SOLUTION\n")
    # IO.write("-----------> Fitness: #{soln.fitness}\n")
    # IO.write("-----------> Genes\n")

    # TODO: Update todos based on the time generated by GA.
    soln.genes
    |> Matrex.to_list_of_lists()
    |> Core.Timetable.from_bit_timetable()
    |> Core.Timetable.sort_todos(todos)
    |> Core.Timetable.from_schedule(todos, time_streaks, true)
    |> multi_update()
  end

  defp multi_update(todos_with_changes) do
    # Updates the list of todos based on what the scheduler generates.
    multi = Multi.new()

    todos_with_changes
    |> Enum.reduce(multi, fn {todo, attrs}, m_acc ->
      changeset = Butler.Schedules.change_todo(todo, attrs)
      Multi.update(m_acc, todo.id, changeset)
    end)
    |> Butler.Repo.transaction()
  end
end
